<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bulk Image Cropper - Fixed Position Mode</title>
    
    <!-- UIkit CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/uikit@3.16.26/dist/css/uikit.min.css" />
    
    <!-- Cropper.js CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cropperjs@1.5.13/dist/cropper.min.css">
    
    <style>
        .cropper-container {
            max-height: 70vh;
            margin: 0 auto;
        }
        
        .locked-indicator {
            background: #ffd700;
            color: #333;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            font-weight: bold;
            text-align: center;
        }
        
        .template-indicator {
            background: #32d296;
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            display: inline-block;
            margin-bottom: 10px;
        }
        
        .view-only-mode {
            opacity: 0.8;
            pointer-events: none;
        }
        
        .validation-error {
            background: #f0506e;
            color: white;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        
        .image-counter {
            font-size: 1.2em;
            margin-bottom: 15px;
        }
        
        .template-set {
            border: 3px solid #32d296 !important;
        }
        
        #image-to-crop {
            max-width: 100%;
            display: block;
        }
        
        .cropper-view-box,
        .cropper-face {
            border-radius: 0;
        }
        
        .controls-section {
            background: #f8f8f8;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
        }
        
        .nav-button {
            min-width: 120px;
        }
        
        .file-input-wrapper {
            margin-bottom: 20px;
        }
    </style>
</head>
<body>

<div id="app" class="uk-container uk-container-large uk-padding">
    
    <!-- Header -->
    <div class="uk-text-center uk-margin-large-bottom">
        <h1 class="uk-heading-medium">Bulk Image Cropper</h1>
        <p class="uk-text-lead">Set crop on first image, apply to all images automatically</p>
    </div>

    <!-- File Input Section -->
    <div class="file-input-wrapper uk-text-center" v-if="!images.length">
        <div uk-form-custom="target: true">
            <input type="file" multiple accept="image/*" @change="handleFileSelect">
            <input class="uk-input uk-form-width-large" type="text" placeholder="Select images..." disabled>
        </div>
        <button class="uk-button uk-button-primary uk-margin-left" type="button" tabindex="-1">Select Images</button>
        <p class="uk-text-meta uk-margin-top">Select multiple images to crop. First image sets the template.</p>
    </div>

    <!-- Main Editor Section -->
    <div v-if="images.length > 0">
        
        <!-- Status Indicators -->
        <div class="uk-margin-bottom">
            <div class="image-counter">
                Image {{ currentIndex + 1 }} of {{ images.length }}
            </div>
            
            <!-- Template Status -->
            <div v-if="currentIndex === 0 && !templateSet" class="uk-alert-primary" uk-alert>
                <p><strong>Template Mode:</strong> Adjust the crop area on this first image, then click "Set as Template"</p>
            </div>
            
            <div v-if="currentIndex === 0 && templateSet" class="template-indicator">
                ‚úì Template Set - Crop position locked
            </div>
            
            <!-- Locked Mode Indicator -->
            <div v-if="currentIndex > 0 && templateSet" class="locked-indicator">
                üîí View Only Mode - Using template crop position ({{ templateCropData.width.toFixed(0) }}√ó{{ templateCropData.height.toFixed(0) }}px at X:{{ templateCropData.x.toFixed(0) }}, Y:{{ templateCropData.y.toFixed(0) }})
            </div>
            
            <div v-if="currentIndex > 0 && !templateSet" class="uk-alert-warning" uk-alert>
                <p>Please set the template on the first image before proceeding</p>
            </div>
            
            <!-- Validation Error -->
            <div v-if="validationError" class="validation-error">
                {{ validationError }}
            </div>
        </div>

        <!-- Image Display Area -->
        <div class="uk-grid uk-grid-match" uk-grid>
            <div class="uk-width-3-4@m">
                <div class="cropper-container" :class="{ 'template-set': currentIndex === 0 && templateSet }">
                    <img id="image-to-crop" :src="currentImageUrl" alt="Image to crop">
                </div>
            </div>
            
            <!-- Controls Sidebar -->
            <div class="uk-width-1-4@m">
                <div class="controls-section">
                    
                    <!-- Template Controls (First Image Only) -->
                    <div v-if="currentIndex === 0">
                        <h4>Template Controls</h4>
                        
                        <div class="uk-margin">
                            <label class="uk-form-label">Aspect Ratio</label>
                            <select class="uk-select" v-model="aspectRatio" @change="updateAspectRatio">
                                <option value="NaN">Free</option>
                                <option value="1">1:1 (Square)</option>
                                <option value="1.7777777777777777">16:9</option>
                                <option value="1.3333333333333333">4:3</option>
                                <option value="0.6666666666666666">2:3</option>
                                <option value="0.5625">9:16</option>
                            </select>
                        </div>
                        
                        <button 
                            class="uk-button uk-button-primary uk-width-1-1 uk-margin-small-bottom" 
                            @click="setTemplate"
                            :disabled="templateSet">
                            {{ templateSet ? 'Template Set ‚úì' : 'Set as Template' }}
                        </button>
                        
                        <button 
                            v-if="templateSet"
                            class="uk-button uk-button-secondary uk-width-1-1 uk-margin-small-bottom" 
                            @click="resetTemplate">
                            Reset Template
                        </button>
                    </div>
                    
                    <!-- Navigation Controls -->
                    <div class="uk-margin-top">
                        <h4>Navigation</h4>
                        <div class="uk-button-group uk-width-1-1">
                            <button 
                                class="uk-button uk-button-default nav-button" 
                                @click="prevImage"
                                :disabled="currentIndex === 0">
                                ‚Üê Previous
                            </button>
                            <button 
                                class="uk-button uk-button-default nav-button" 
                                @click="nextImage"
                                :disabled="currentIndex === images.length - 1">
                                Next ‚Üí
                            </button>
                        </div>
                    </div>
                    
                    <!-- Action Buttons -->
                    <div class="uk-margin-top">
                        <h4>Actions</h4>
                        <button 
                            class="uk-button uk-button-danger uk-width-1-1 uk-margin-small-bottom" 
                            @click="removeCurrentImage">
                            Remove This Image
                        </button>
                        
                        <button 
                            class="uk-button uk-button-primary uk-width-1-1" 
                            @click="processAllImages"
                            :disabled="!templateSet || processing">
                            {{ processing ? 'Processing...' : 'Crop All & Download ZIP' }}
                        </button>
                    </div>
                    
                    <!-- Image List -->
                    <div class="uk-margin-top">
                        <h4>Image List</h4>
                        <ul class="uk-list uk-list-divider">
                            <li 
                                v-for="(img, idx) in images" 
                                :key="idx"
                                @click="goToImage(idx)"
                                :class="{ 'uk-text-bold': idx === currentIndex, 'uk-text-success': idx === 0 && templateSet }"
                                style="cursor: pointer;">
                                {{ idx + 1 }}. {{ img.name }}
                                <span v-if="idx === 0 && templateSet" class="uk-label uk-label-success">TEMPLATE</span>
                                <span v-if="idx > 0 && templateSet" class="uk-label">locked</span>
                            </li>
                        </ul>
                    </div>
                    
                </div>
            </div>
        </div>
    </div>

    <!-- Hidden Canvas for Processing -->
    <canvas id="process-canvas" style="display: none;"></canvas>

</div>

<!-- Scripts -->
<script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/uikit@3.16.26/dist/js/uikit.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/uikit@3.16.26/dist/js/uikit-icons.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/cropperjs@1.5.13/dist/cropper.min.js"></script>

<script>
new Vue({
    el: '#app',
    data: {
        images: [],           // Array of { file, name, url, valid }
        currentIndex: 0,      // Current image index
        cropper: null,        // Cropper.js instance
        aspectRatio: 'NaN',   // Current aspect ratio
        templateSet: false,   // Whether template has been set
        templateCropData: null, // { x, y, width, height } in pixels
        processing: false,    // Whether currently processing
        validationError: '',  // Current validation error message
        processedImages: []   // Array of processed blobs
    },
    
    computed: {
        currentImage: function() {
            return this.images[this.currentIndex] || null;
        },
        currentImageUrl: function() {
            return this.currentImage ? this.currentImage.url : '';
        }
    },
    
    watch: {
        currentIndex: function() {
            this.$nextTick(() => {
                this.initCropper();
            });
        }
    },
    
    methods: {
        // Handle file selection
        handleFileSelect: function(event) {
            var files = Array.from(event.target.files);
            var self = this;
            
            files.forEach(function(file) {
                if (!file.type.startsWith('image/')) return;
                
                var url = URL.createObjectURL(file);
                self.images.push({
                    file: file,
                    name: file.name,
                    url: url,
                    valid: true
                });
            });
            
            // Initialize cropper for first image
            if (this.images.length > 0) {
                this.$nextTick(() => {
                    this.initCropper();
                });
            }
        },
        
        // Initialize or reinitialize cropper
        initCropper: function() {
            var self = this;
            var image = document.getElementById('image-to-crop');
            
            if (!image) return;
            
            // Destroy existing cropper
            if (this.cropper) {
                this.cropper.destroy();
                this.cropper = null;
            }
            
            // Wait for image to load
            if (!image.complete) {
                image.onload = function() {
                    self.setupCropper();
                };
            } else {
                this.setupCropper();
            }
        },
        
        // Setup cropper with appropriate options
        setupCropper: function() {
            var self = this;
            var image = document.getElementById('image-to-crop');
            
            if (!image) return;
            
            var options = {
                viewMode: 1,        // Restrict to image bounds
                dragMode: 'move',
                autoCropArea: 0.8,
                restore: false,
                guides: true,
                center: true,
                highlight: false,
                cropBoxMovable: true,
                cropBoxResizable: true,
                toggleDragModeOnDblclick: false,
                ready: function() {
                    // If template is set and we're not on first image, apply template
                    if (self.templateSet && self.currentIndex > 0) {
                        self.applyTemplateCrop();
                    }
                }
            };
            
            // Set aspect ratio if specified
            if (this.aspectRatio !== 'NaN') {
                options.aspectRatio = parseFloat(this.aspectRatio);
            }
            
            // Disable interaction for subsequent images when template is set
            if (this.currentIndex > 0 && this.templateSet) {
                options.cropBoxMovable = false;
                options.cropBoxResizable = false;
                options.dragMode = 'none';
                options.toggleDragModeOnDblclick = false;
            }
            
            this.cropper = new Cropper(image, options);
        },
        
        // Set current crop as template
        setTemplate: function() {
            if (!this.cropper || this.currentIndex !== 0) return;
            
            var data = this.cropper.getData();
            
            // Validate crop data
            if (data.width < 10 || data.height < 10) {
                alert('Crop area too small. Please select a larger area.');
                return;
            }
            
            this.templateCropData = {
                x: data.x,
                y: data.y,
                width: data.width,
                height: data.height
            };
            
            this.templateSet = true;
            
            // Reinitialize to lock the template image too
            this.cropper.setData(this.templateCropData);
            
            // Disable further changes on template
            this.cropper.setDragMode('none');
            this.cropper.options.cropBoxMovable = false;
            this.cropper.options.cropBoxResizable = false;
            
            alert('Template set! Crop position will be applied to all images.');
        },
        
        // Reset template to allow changes
        resetTemplate: function() {
            if (!confirm('Reset template? You will need to set it again.')) return;
            
            this.templateSet = false;
            this.templateCropData = null;
            
            // Reinitialize cropper to enable editing
            this.initCropper();
        },
        
        // Apply template crop to current image
        applyTemplateCrop: function() {
            if (!this.cropper || !this.templateCropData) return;
            
            var self = this;
            var image = document.getElementById('image-to-crop');
            
            // Validate image size
            if (image.naturalWidth < this.templateCropData.x + this.templateCropData.width ||
                image.naturalHeight < this.templateCropData.y + this.templateCropData.height) {
                
                this.validationError = 'Image too small for template crop area! ' +
                    'Need ' + this.templateCropData.width.toFixed(0) + '√ó' + this.templateCropData.height.toFixed(0) + 
                    ', got ' + image.naturalWidth + '√ó' + image.naturalHeight;
                
                this.currentImage.valid = false;
                return;
            } else {
                this.validationError = '';
                this.currentImage.valid = true;
            }
            
            // Apply template data
            this.cropper.setData(this.templateCropData);
            
            // Ensure crop box is not movable/resizable
            this.cropper.setDragMode('none');
        },
        
        // Update aspect ratio
        updateAspectRatio: function() {
            if (!this.cropper) return;
            
            var ratio = this.aspectRatio === 'NaN' ? NaN : parseFloat(this.aspectRatio);
            this.cropper.setAspectRatio(ratio);
        },
        
        // Navigation
        nextImage: function() {
            if (this.currentIndex < this.images.length - 1) {
                this.currentIndex++;
            }
        },
        
        prevImage: function() {
            if (this.currentIndex > 0) {
                this.currentIndex--;
            }
        },
        
        goToImage: function(index) {
            if (index >= 0 && index < this.images.length) {
                // Check if template is set before allowing navigation away from first image
                if (this.currentIndex === 0 && !this.templateSet && index > 0) {
                    alert('Please set the template on the first image before viewing other images.');
                    return;
                }
                this.currentIndex = index;
            }
        },
        
        // Remove current image
        removeCurrentImage: function() {
            if (!confirm('Remove this image from the list?')) return;
            
            // Revoke object URL to free memory
            URL.revokeObjectURL(this.currentImage.url);
            
            this.images.splice(this.currentIndex, 1);
            
            if (this.currentIndex >= this.images.length) {
                this.currentIndex = Math.max(0, this.images.length - 1);
            }
            
            if (this.images.length === 0) {
                this.templateSet = false;
                this.templateCropData = null;
            }
        },
        
        // Process all images and create ZIP
        processAllImages: function() {
            if (!this.templateSet) {
                alert('Please set a template first!');
                return;
            }
            
            // Check for invalid images
            var invalidImages = this.images.filter(function(img, idx) { 
                return idx > 0 && !img.valid; 
            });
            
            if (invalidImages.length > 0) {
                alert('Some images are too small for the template crop area. Please remove them or reset the template.');
                return;
            }
            
            this.processing = true;
            this.processedImages = [];
            
            var self = this;
            var canvas = document.getElementById('process-canvas');
            var ctx = canvas.getContext('2d');
            
            // Process each image
            var processNext = function(index) {
                if (index >= self.images.length) {
                    // All done, create ZIP
                    self.createZip();
                    return;
                }
                
                var img = self.images[index];
                var imageObj = new Image();
                
                imageObj.onload = function() {
                    // Set canvas size to crop size
                    canvas.width = self.templateCropData.width;
                    canvas.height = self.templateCropData.height;
                    
                    // Draw cropped region
                    ctx.drawImage(
                        imageObj,
                        self.templateCropData.x,
                        self.templateCropData.y,
                        self.templateCropData.width,
                        self.templateCropData.height,
                        0,
                        0,
                        self.templateCropData.width,
                        self.templateCropData.height
                    );
                    
                    // Convert to blob
                    canvas.toBlob(function(blob) {
                        self.processedImages.push({
                            name: 'cropped_' + img.name,
                            blob: blob,
                            originalName: img.name
                        });
                        
                        // Process next
                        processNext(index + 1);
                    }, 'image/jpeg', 0.95);
                };
                
                imageObj.src = img.url;
            };
            
            // Start processing
            processNext(0);
        },
        
        // Create and download ZIP using Web Worker
        createZip: function() {
            var self = this;
            
            // Create worker from inline code
            var workerScript = document.getElementById('zip-worker-code').textContent;
            var blob = new Blob([workerScript], { type: 'text/javascript' });
            var workerUrl = URL.createObjectURL(blob);
            
            var worker = new Worker(workerUrl);
            
            worker.onmessage = function(e) {
                var zipBlob = new Blob([e.data.zip], { type: 'application/zip' });
                var url = URL.createObjectURL(zipBlob);
                
                // Trigger download
                var a = document.createElement('a');
                a.href = url;
                a.download = 'cropped_images.zip';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                URL.revokeObjectURL(url);
                URL.revokeObjectURL(workerUrl);
                
                self.processing = false;
                
                alert('Download started! Cropped ' + self.processedImages.length + ' images.');
            };
            
            // Send files to worker
            worker.postMessage(this.processedImages);
        }
    },
    
    beforeDestroy: function() {
        // Clean up object URLs
        this.images.forEach(function(img) {
            URL.revokeObjectURL(img.url);
        });
        
        if (this.cropper) {
            this.cropper.destroy();
        }
    }
});
</script>

<!-- Inline Web Worker Code -->
<script id="zip-worker-code" type="text/js-worker">
function Stream(byteLength, littleEndian) {
    var instance = this;
    this._array = new ArrayBuffer(byteLength);
    this._view = new DataView(this._array, 0, byteLength);
    this._capacity = byteLength;
    this._length = 0;
    this._le = littleEndian;

    this._resize = function(extraCapacity) {
        if (instance._capacity >= instance._length + extraCapacity) {
            return;
        }

        var newCapacity = instance._capacity * 2;
        while (newCapacity < instance._length + extraCapacity) {
            newCapacity *= 2;
        }

        var newArray = new ArrayBuffer(newCapacity);
        var newView = new DataView(newArray, 0, newCapacity);
        for (var i = 0; i < instance._length; i++) {
            newView.setUint8(i, instance._view.getUint8(i));
        }
        instance._array = newArray;
        instance._view = newView;
        instance._capacity = newCapacity;
    };

    this.writeUint8 = function(byte) {
        instance._resize(1);
        instance._view.setUint8(instance._length, byte);
        instance._length++;
    };

    this.writeUint16 = function(uint16) {
        instance._resize(2);
        instance._view.setUint16(instance._length, uint16, instance._le);
        instance._length += 2;
    };

    this.writeUint32 = function(uint32) {
        instance._resize(4);
        instance._view.setUint32(instance._length, uint32, instance._le);
        instance._length += 4;
    };

    this.writeUint8Array = function(arr) {
        instance._resize(arr.length);
        for (var i = 0; i < arr.length; i++) {
            instance._view.setUint8(instance._length, arr[i], instance._le);
            instance._length++;
        }
    };

    this.finalize = function() {
        var newArray = new ArrayBuffer(instance._length);
        var newView = new DataView(newArray, 0, instance._length);

        for (var i = 0; i < instance._length; i++) {
            newView.setUint8(i, instance._view.getUint8(i));
        }

        return newArray;
    }
}

function makeTable() {
    var c, table = [];

    for(var n =0; n < 256; n++){
        c = n;
        for(var k =0; k < 8; k++){
            c = ((c&1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
        }
        table[n] = c;
    }

    return table;
}

var crcTable = makeTable();

function crc32(crc, buf, len, pos) {
    var t = crcTable, end = pos + len;
    crc = crc ^ (-1);

    for (var i = pos; i < end; i++ ) {
        crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
    }

    return (crc ^ (-1));
}

function calcCrc32(ab) {
    return crc32(0, new Uint8Array(ab, 0, ab.byteLength), ab.byteLength, 0);
}

function toUTF8Array(str) {
    var utf8 = [];
    for (var i=0; i < str.length; i++) {
        var charcode = str.charCodeAt(i);
        if (charcode < 0x80) utf8.push(charcode);
        else if (charcode < 0x800) {
            utf8.push(0xc0 | (charcode >> 6),
            0x80 | (charcode & 0x3f));
        }
        else if (charcode < 0xd800 || charcode >= 0xe000) {
            utf8.push(0xe0 | (charcode >> 12),
            0x80 | ((charcode>>6) & 0x3f),
            0x80 | (charcode & 0x3f));
        }
        else {
            i++;
            charcode = 0x10000 + (((charcode & 0x3ff)<<10)
            | (str.charCodeAt(i) & 0x3ff))
            utf8.push(0xf0 | (charcode >>18),
            0x80 | ((charcode>>12) & 0x3f),
            0x80 | ((charcode>>6) & 0x3f),
            0x80 | (charcode & 0x3f));
        }
    }
    return utf8;
}

function createZip(fileQueue) {
    var zip = new Stream(128000, true);
    var date = new Date();

    var dosTime = date.getHours();
    dosTime = dosTime << 6;
    dosTime = dosTime | date.getMinutes();
    dosTime = dosTime << 5;
    dosTime = dosTime | date.getSeconds() / 2;

    var dosDate = date.getFullYear() - 1980;
    dosDate = dosDate << 4;
    dosDate = dosDate | (date.getMonth() + 1);
    dosDate = dosDate << 5;
    dosDate = dosDate | date.getDate();

    for (var i = 0; i < fileQueue.length; i++) {
        fileQueue[i].offset = zip._length;

        zip.writeUint8Array([0x50, 0x4b, 0x03, 0x04]);
        zip.writeUint16(0x0014);
        zip.writeUint16(0x0800);
        zip.writeUint16(0x00);
        zip.writeUint16(dosTime);
        zip.writeUint16(dosDate);
        zip.writeUint32(fileQueue[i].crc);
        zip.writeUint32(fileQueue[i].buffer.byteLength);
        zip.writeUint32(fileQueue[i].buffer.byteLength);

        var utf8 = toUTF8Array(fileQueue[i].name);
        zip.writeUint16(utf8.length);
        zip.writeUint16(0x00);
        zip.writeUint8Array(utf8);

        var src = new Uint8Array(fileQueue[i].buffer, 0, fileQueue[i].buffer.byteLength);
        var srclen = fileQueue[i].buffer.byteLength;

        for (var j = 0; j < srclen; j++) {
            zip.writeUint8(src[j]);
        }
    }

    var centralDirectoryOffset = zip._length;

    for (var k = 0; k < fileQueue.length; k++) {
        zip.writeUint8Array([0x50, 0x4b, 0x01, 0x02]);
        zip.writeUint16(0x0014);
        zip.writeUint16(0x00A0);
        zip.writeUint16(0x0800);
        zip.writeUint16(0x00);
        zip.writeUint16(dosTime);
        zip.writeUint16(dosDate);
        zip.writeUint32(fileQueue[k].crc);
        zip.writeUint32(fileQueue[k].buffer.byteLength);
        zip.writeUint32(fileQueue[k].buffer.byteLength);

        var utf8c = toUTF8Array(fileQueue[k].name);
        zip.writeUint16(utf8c.length);
        zip.writeUint16(0x00);
        zip.writeUint16(0x00);
        zip.writeUint16(0x00);
        zip.writeUint16(0x00);
        zip.writeUint32(0x00);
        zip.writeUint32(fileQueue[k].offset);
        zip.writeUint8Array(utf8c);
    }

    var endCentralDirectory = zip._length;

    zip.writeUint8Array([0x50, 0x4b, 0x05, 0x06]);
    zip.writeUint16(0x00);
    zip.writeUint16(0x00);
    zip.writeUint16(fileQueue.length);
    zip.writeUint16(fileQueue.length);
    zip.writeUint32(endCentralDirectory - centralDirectoryOffset);
    zip.writeUint32(centralDirectoryOffset);
    zip.writeUint16(0x00);

    var zipBuffer = zip.finalize();
    postMessage({ zip: zipBuffer });
}

onmessage = function(e) {
    var fileQueue = e.data;

    if (fileQueue.length === 0) {
        return;
    }

    var idx = 0;
    var fr = new FileReader();

    fr.onload = function(e) {
        fileQueue[idx].buffer = e.target.result;
        fileQueue[idx].crc = calcCrc32(fileQueue[idx].buffer);
        idx++;
        if (idx >= fileQueue.length) {
            createZip(fileQueue);
        } else {
            fr.readAsArrayBuffer(fileQueue[idx].blob);
        }
    };

    fr.readAsArrayBuffer(fileQueue[0].blob);
};
</script>

</body>
</html>